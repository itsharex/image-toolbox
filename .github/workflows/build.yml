name: Build

on:
  workflow_dispatch:
  # 建议添加 push 事件，以便在开发时自动测试构建
  # push:
  #   branches: [ main ]

jobs:
  build-windows-x64:
    name: Build Windows x64
    runs-on: windows-latest

    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js (LTS)
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      # 1. 替换废弃的 actions-rs，使用官方推荐的 rust-toolchain
      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      # 2. 使用专业的 Rust 缓存 Action (替代手动 cache 步骤)
      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install npm dependencies
        run: npm ci

      - name: Build frontend
        run: npm run build

      # 3. 移除了 choco install wixtoolset (windows-latest 已内置)

      - name: Build Tauri bundles
        run: npm run tauri build
        env:
          CI: true

      # --- MSIX Packaging & Signing Steps Start ---
      - name: Package MSIX
        shell: pwsh
        run: |
          # 1. Prepare Directory Structure
          $distDir = "msix-dist"
          $iconDir = "$distDir\icons"
          New-Item -ItemType Directory -Force -Path $iconDir

          # 2. Copy Executable & Resources
          # Note: Adjust path if your exe name differs. Usually project-name.exe
          Copy-Item "src-tauri/target/release/image-toolbox.exe" -Destination "$distDir\image-toolbox.exe"
          
          # Copy all icons
          Copy-Item "src-tauri/icons\*" -Destination $iconDir
          
          # Copy Manifest
          Copy-Item "src-tauri/AppxManifest.xml" -Destination "$distDir\AppxManifest.xml"

          # 3. Pack MSIX
          $msixPath = "src-tauri/target/release/bundle/msix/image-toolbox.msix"
          New-Item -ItemType Directory -Force -Path "src-tauri/target/release/bundle/msix"
          
          # Use MakeAppx from Windows SDK (available in path on windows-latest)
          MakeAppx pack /d "$distDir" /p "$msixPath" /o

      - name: Sign MSIX
        shell: pwsh
        env:
          CERTIFICATE_BASE64: ${{ secrets.WINDOWS_PFX_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_PFX_PASSWORD }}
        run: |
          $msixPath = "src-tauri/target/release/bundle/msix/image-toolbox.msix"
          
          if ($env:CERTIFICATE_BASE64) {
            Write-Host "Signing with provided certificate..."
            $pfxPath = "cert.pfx"
            [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:CERTIFICATE_BASE64))
            
            & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe" sign /f $pfxPath /p "$env:CERTIFICATE_PASSWORD" /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 $msixPath
            Remove-Item $pfxPath
          } else {
            Write-Host "No certificate secret found. Generating self-signed certificate for testing..."
            # Create Self-Signed Cert
            $cert = New-SelfSignedCertificate -Type Custom -Subject "CN=u202f" -KeyUsage DigitalSignature -FriendlyName "ImageToolbox Test Cert" -CertStoreLocation "Cert:\CurrentUser\My" -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.3", "2.5.29.19={text}")
            
            # Export PFX
            $pfxPath = "self-signed.pfx"
            $password = ConvertTo-SecureString -String "password" -Force -AsPlainText
            Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $password
            
            # Sign
            & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe" sign /f $pfxPath /p "password" /fd SHA256 $msixPath
            
            Write-Warning "This MSIX is signed with a self-signed certificate. You must install the certificate to 'Trusted Root Certification Authorities' to install the app."
          }
      # --- MSIX Packaging & Signing Steps End ---

      - name: Rename Artifacts
        shell: pwsh
        run: |
          $version = (Get-Content "package.json" | ConvertFrom-Json).version
          
          # Rename Portable EXE
          $portableSrc = "src-tauri/target/release/image-toolbox.exe"
          $portableDst = "src-tauri/target/release/image-toolbox_portable.exe"
          if (Test-Path $portableSrc) {
            Write-Host "Renaming $portableSrc to $portableDst"
            Move-Item $portableSrc $portableDst
          }

          # Rename MSI
          $msiDir = "src-tauri/target/release/bundle/msi"
          $msiSrc = Get-ChildItem "$msiDir\*.msi" | Select-Object -First 1
          if ($msiSrc) {
             $msiDst = "$msiDir\image-toolbox_${version}_x64-setup.msi"
             Write-Host "Renaming $($msiSrc.FullName) to $msiDst"
             Move-Item $msiSrc.FullName $msiDst
          }

      # 4. 仅用于调试，生产环境可移除
      - name: List Output Files (Debug)
        shell: pwsh
        run: |
          Get-ChildItem -Recurse -File src-tauri/target/release/bundle | Select-Object FullName, Length

      # 5. 优化上传路径，只保留安装包
      - name: Upload Windows build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-x64-installer
          path: |
            LICENSE
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/msix/*.msix
            src-tauri/target/release/image-toolbox_portable.exe
          if-no-files-found: error
